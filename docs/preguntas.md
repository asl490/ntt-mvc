1. Java Core (50 preguntas)

Diferencia entre clase abstracta e interfaz.

Qué es Optional y cuándo usarlo.

Diferencia entre == y .equals().

Qué es un Singleton y cómo hacerlo thread-safe.

Qué es un constructor estático.

Qué son las excepciones checked y unchecked.

Cómo funciona el garbage collector.

Diferencia entre stack y heap.

Qué es final, finally y finalize.

Diferencia entre String, StringBuilder y StringBuffer.

Diferencia entre sobrecarga (overload) y sobrescritura (override).

Qué es polimorfismo y tipos.

Qué es encapsulamiento y su importancia.

Qué es herencia y cómo se aplica.

Qué es el operador instanceof y cómo usarlo.

Qué es la palabra clave super y this.

Diferencia entre static y instance members.

Qué son bloques estáticos y de instancia.

Qué es varargs y cómo se usa.

Diferencia entre enum y constantes estáticas.

Qué son las expresiones lambda y ventajas.

Diferencia entre Stream y Collection.

Qué es el API Stream y operaciones intermedias/finales.

Diferencia entre map() y flatMap().

Qué son las referencias a métodos.

Qué es Optional.isPresent() y orElse().

Cómo funcionan los predicados en Java.

Diferencia entre HashMap y TreeMap.

Diferencia entre HashSet y TreeSet.

Diferencia entre LinkedList y ArrayList.

Qué es Comparable y Comparator.

Qué es Iterator y ListIterator.

Qué son WeakHashMap y IdentityHashMap.

Qué son colecciones synchronized y concurrentes.

Diferencia entre copy-on-write y synchronized collections.

Qué es Serializable y cómo se usa.

Qué es transient y su uso.

Diferencia entre shallow copy y deep copy.

Qué es clone() y cómo implementarlo correctamente.

Qué es reflection y usos.

Qué son annotations y ejemplos comunes.

Diferencia entre @Override y @Deprecated.

Qué son generics y beneficios.

Qué es type erasure.

Qué es wildcards en generics (? extends / ? super).

Qué es var y cuándo usarlo.

Diferencia entre interface funcional y abstract class.

Qué es record en Java 16+.

Qué son sealed classes en Java 17+.

Qué es pattern matching para instanceof.

2. Concurrencia y Multihilo (30 preguntas)

Diferencia entre Thread y Runnable.

Qué es ExecutorService y ventajas.

Diferencia entre Future y CompletableFuture.

Qué es synchronized y ReentrantLock.

Qué es un race condition.

Qué es un deadlock.

Cómo prevenir deadlocks.

Qué significa volatile.

Qué es wait(), notify() y notifyAll().

Diferencia entre notify() y notifyAll().

Qué es thread-safe.

Qué es un CountDownLatch.

Qué es CyclicBarrier.

Qué es Semaphore.

Qué es Lock y ReadWriteLock.

Qué son ConcurrentHashMap y CopyOnWriteArrayList.

Qué es fork/join framework.

Diferencia entre parallelStream() y stream().

Qué es AtomicInteger y clases atómicas.

Diferencia entre spinlock y lock blocking.

Qué es la sincronización fina (fine-grained locking).

Qué es la sincronización gruesa (coarse-grained).

Qué es un thread pool.

Qué es daemon thread.

Qué es ThreadLocal y usos.

Cómo se maneja interrupción de hilos.

Qué es fair lock.

Qué es busy-waiting y cómo evitarlo.

Diferencia entre wait-notify y Condition.

Qué son los hazards en concurrencia (ABA problem).

3. Patrones de diseño (20 preguntas)

Qué es Singleton y variantes thread-safe.

Qué es Factory y Factory Method.

Qué es Abstract Factory.

Qué es Builder.

Qué es Prototype.

Qué es Observer.

Qué es Strategy.

Qué es Command.

Qué es DAO y Repository.

Qué es Dependency Injection.

Qué es Adapter.

Qué es Decorator.

Qué es Facade.

Qué es Composite.

Qué es Proxy.

Qué es Mediator.

Qué es Template Method.

Qué es State.

Qué es Chain of Responsibility.

Qué es Circuit Breaker en microservicios.

4. Spring y Spring Boot (30 preguntas)

Qué es IoC y contenedor de Spring.

Diferencia entre @Component, @Service y @Repository.

Qué es @Autowired.

Tipos de inyección de dependencias.

Qué es @Transactional y ejemplos.

Qué es @RestController vs @Controller.

Diferencia entre @RequestMapping, @GetMapping, @PostMapping.

Qué son los scopes de beans (Singleton, Prototype, Request, Session).

Qué es @Qualifier y cuándo usarlo.

Qué es ApplicationContext vs BeanFactory.

Qué es @Value y cómo inyectar propiedades.

Qué es @Configuration y @Bean.

Qué es @ControllerAdvice y @ExceptionHandler.

Cómo se manejan excepciones globales en Spring.

Qué es Spring Boot y ventajas.

Qué es autoconfiguración.

Qué es starter dependency.

Qué es actuator y monitorización.

Qué es profile en Spring.

Qué es Spring Data JPA y diferencias con Hibernate.

Qué es @Entity, @Table, @Id.

Qué es @OneToMany y @ManyToOne.

Diferencia entre LAZY y EAGER.

Qué es Pageable y Sort en Spring Data.

Qué es RestTemplate y WebClient.

Qué es HATEOAS.

Cómo versionar APIs en Spring.

Qué es CORS y cómo configurarlo.

Qué es Spring Security básico.

Qué es JWT y cómo se integra en Spring.

5. Microservicios y Arquitectura Distribuida (40 preguntas)

Qué es un microservicio.

Diferencia entre monolito y microservicio.

Qué es REST y principios básicos (stateless, URIs, verbs HTTP).

Diferencia entre PUT y POST.

Qué es idempotencia y ejemplos en APIs.

Qué es versionado de APIs y estrategias.

Qué es caching y cómo usar Redis.

Qué es SAGA y cómo funciona en transacciones distribuidas.

Qué es consistencia eventual.

Diferencia entre transacción ACID y BASE.

Qué es un API Gateway.

Qué es service discovery.

Qué es load balancing en microservicios.

Qué es circuit breaker y cómo mejora resiliencia.

Qué es retry con backoff exponencial.

Qué es throttling y rate limiting.

Qué es publish/subscribe y cómo funciona en Kafka.

Qué es messaging asincrónico y ventajas.

Diferencia entre topic y queue en Kafka.

Qué es consumer group en Kafka.

Qué es partitioning en Kafka y su importancia.

Qué es offset en Kafka.

Qué es idempotencia en procesamiento de mensajes.

Qué es stream processing y ejemplos.

Qué es dead letter queue y para qué se usa.

Qué es event sourcing.

Qué es CQRS (Command Query Responsibility Segregation).

Qué es throttling en APIs.

Qué es rate limiting y cómo aplicarlo.

Diferencia entre request-response y messaging.

Qué es latency y cómo medirlo en microservicios.

Qué es resiliencia en sistemas distribuidos.

Diferencia entre synchronous y asynchronous communication.

Qué es monitoring y observability en microservicios.

Qué es logging centralizado.

Qué es tracing distribuido y herramientas (Jaeger, Zipkin).

Qué es health check y readiness/liveness probes.

Diferencia entre stateful y stateless service.

Qué es containerization y ventajas.

Diferencia entre Docker y Kubernetes.

6. Testing y Calidad de Código (30 preguntas)

Diferencia entre unit test y integration test.

Qué son mocks, stubs y spies.

Cómo hacer pruebas unitarias con JUnit.

Cómo hacer pruebas unitarias con Spock.

Qué es test coverage.

Qué es TDD (Test Driven Development).

Qué es BDD (Behavior Driven Development).

Diferencia entre black-box y white-box testing.

Qué son pruebas funcionales en backend.

Qué es regression testing.

Qué son pruebas de performance y stress testing.

Qué es test fixture.

Cómo usar @BeforeEach, @AfterEach, @BeforeAll, @AfterAll.

Qué es assertEquals, assertTrue, assertThrows.

Qué es mocking con Mockito o Spock.

Qué es spy y cuándo se usa.

Qué es integration testing con Spring Boot (@SpringBootTest).

Qué es contract testing en microservicios.

Qué son pruebas end-to-end.

Diferencia entre unit test y integration test de base de datos.

Qué es test isolation y por qué es importante.

Qué son fixtures y datos de prueba.

Cómo manejar dependencias externas en tests.

Qué es code smell y refactoring.

Qué es static code analysis y herramientas (SonarQube).

Qué es mutation testing.

Qué es CI/CD testing pipeline.

Qué es test-driven deployment.

Qué es feature toggling y pruebas en producción.

Buenas prácticas de testing en microservicios.

7. DevOps y Cloud (Jenkins, Azure, CI/CD) (30 preguntas)

Qué es Jenkins y para qué sirve.

Qué es un pipeline de CI/CD.

Diferencia entre build, deploy y release.

Qué es Continuous Integration.

Qué es Continuous Delivery.

Qué es Continuous Deployment.

Qué son stages y jobs en Jenkins.

Qué es un Jenkinsfile y declarative vs scripted pipelines.

Qué es version control y branch strategy (GitFlow).

Cómo integrar pruebas unitarias en Jenkins pipeline.

Cómo hacer build de microservicios Spring Boot en pipeline.

Cómo desplegar a Azure App Services.

Diferencia entre App Service y contenedor en Azure.

Qué es Azure DevOps.

Qué es artifact repository y ejemplos (Nexus, Artifactory).

Qué es Dockerfile y cómo crear imágenes.

Qué es container registry.

Diferencia entre Kubernetes Deployment y StatefulSet.

Qué es Helm y charts en Kubernetes.

Qué es CI/CD seguro y buenas prácticas.

Qué es rolling update y rollback.

Qué es blue/green deployment.

Qué es canary deployment.

Qué es pipeline as code.

Cómo monitorear pipelines y alertas.

Qué es infrastructure as code (IaC) y ejemplos.

Qué es Terraform y cómo se integra con Azure.

Qué es secret management en pipelines.

Qué es cloud-native application.

Diferencias entre IaaS, PaaS y SaaS.

8. Seguridad y Buenas Prácticas (20 preguntas)

Qué es JWT y cómo funciona en autenticación.

Qué es OAuth2 y para qué se usa.

Diferencia entre autenticación y autorización.

Qué es SQL Injection y cómo prevenirlo.

Qué es XSS y cómo mitigarlo.

Qué es CSRF y cómo prevenirlo.

Qué es CORS y cómo configurarlo en Spring.

Qué es hashing y diferencia con cifrado.

Qué es SSL/TLS y por qué es importante.

Qué es OAuth2 Client Credentials vs Authorization Code.

Qué es OAuth2 Resource Server.

Qué es refresh token y access token.

Qué es password hashing y algoritmos recomendados (BCrypt, Argon2).

Qué es seguridad en microservicios.

Qué es API key y cuándo usarlo.

Qué es rate limiting y cómo mejora seguridad.

Qué es logging seguro (no exponer datos sensibles).

Qué son roles y scopes en APIs REST.

Qué es principle of least privilege.

Buenas prácticas de seguridad en backend.